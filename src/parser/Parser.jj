PARSER_BEGIN(Parser)


/** ID lister. */
package src.parser;

import src.astnodes.*;
import src.astnodes.binding.*;
import src.astnodes.control.*;
import src.astnodes.functions.ASTFunction;import src.astnodes.functions.io.out.*;
import src.astnodes.operations.arithmetic.*;
import src.astnodes.operations.relational.*;
import src.astnodes.value.array.ASTArray;import src.astnodes.value.primitives.*;
import src.astnodes.value.record.*;
import src.misc.*;
import src.value.*;
import java.util.*;

public class Parser {}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}

TOKEN :
{
  < INT : (["0"-"9"]) + >
  |
  < FLOAT : <INT> "." (["0"-"9"])* | "." <INT> >
  |
  < Num: (<INT> | <FLOAT>)>
  |
  < BOOL : ("true" | "false") >
  |
  < SETVAL : "->">
  |
  < GETVAL : "<-">
  |
  < QUOTE : "'">
  |
  < PLUS : "+" >
  |
  < MINUS : "-">
  |
  < TIMES : "*">
  |
  < MOD : "%">
  |
  < POW : "^">
  |
  < DIV : "/">
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < LBRACKET : "{">
  |
  < RBRACKET : "}">
  |
  < LSBRACKET : "[">
  |
  < RSBRACKET : "]">
  |
  < LET : "let">
  |
  < MUT : "mut">
  |
  < EQ : "=">
  |
  < SEMCOL: ";" >
  |
  < COMMA : "," >
  |
  < DOT : ".">
  |
  < IF : "if">
  |
  < ELIF : "elif">
  |
  < ELSE : "else">
  |
  < MATCH : "match">
  |
  < VB : "|">
  |
  < WHILE : "while">
  |
  < FOR : "for">
  |
  < IN : "in">
  |
  < DDOT : ":">
  |
  < DEFAULTCASE : "_">
  |
  < GT : ">">
  |
  < GEQT : ">=">
  |
  < LT : "<">
  |
  < LEQT : "<=">
  |
  < DIFF : "!=">
  |
  < NOT : "!">
  |
  < AND : "and">
  |
  < OR : "or">
  |
  < NEW : "new">
  |
  < REF : "val">
  |
  < FUN : "fn">
  |
  < LEN : "#">
  |
  < PRINT : "print">
  |
  < PRINTLN : "println">
  |
  < EXIT : "exit">
  |
  < STR : <QUOTE>((" ")* (<Id>))*<QUOTE> >
  |
  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >

}

ASTNode Start():
{
    ASTNode t;
}
{
   t = Seq() <COMMA> <COMMA>
   { return t; }
}

ASTNode Seq():
{
    Token n;
    ASTNode t1, t2;
}
{
    t1 = SeqE() (<SEMCOL> t2 = SeqE() { t1 = new ASTSeq(t1,t2); })*
    { return t1; }
}

ASTNode SeqE():
{
    Token n;
    ASTNode t1, t2;
}
{
    t1 = BoolAdd() (<SETVAL> t2 = BoolAdd() { t1 = new ASTAssign(t1,t2); })*
    { return t1; }
}

ASTNode BoolAdd() :
{
    Token n;
    ASTNode t1, t2;
}
{
    t1 = BoolMult() (<OR> t2 = BoolMult() { t1 = new ASTOr(t1,t2); })*
    { return t1; }
}

ASTNode BoolMult() :
{
    Token n;
    ASTNode t1, t2;
}
{
    t1 = RelOps() (<AND> t2 = RelOps() { t1 = new ASTAnd(t1,t2); })?
    { return t1; }
}

ASTNode RelOps() :
{
    Token op;
    ASTNode t1, t2;
}
{
    t1 = Exp() (( op= <GT> | op = <GEQT> | op = <LT> | op = <LEQT> | op = <EQ> | op = <DIFF> ) t2 = Exp()
    {
        if (op.kind == GT)
            t1 = new ASTGrt(t1,t2);
        else if (op.kind == GEQT)
            t1 = new ASTGrtEq(t1,t2);
        else if (op.kind == LT)
            t1 = new ASTLwt(t1,t2);
        else if (op.kind == LEQT)
            t1 = new ASTLwtEq(t1,t2);
        else if (op.kind == EQ)
            t1 = new ASTEq(t1,t2);
        else if (op.kind == DIFF)
            t1 = new ASTDiff(t1,t2);
    })?
    { return t1; }
}

ASTNode Exp() :
{
    Token op;
    ASTNode t1, t2;
}
{
     t1=Term() ( ( op=<PLUS> | op=<MINUS> ) t2=Term() 
                 {
         if (op.kind == PLUS)
             t1 = new ASTPlus(t1,t2);
         else  t1 = new ASTSub(t1,t2);
     }
               ) *
     { return t1; } 
}

ASTNode Term() :
{
    Token op;
    ASTNode t1, t2;
}
{
     t1 = Fact() ( ( op=<TIMES> | op=<DIV> | op=<MOD> | op=<POW>) t2 = Term()
 		 {
       if (op.kind == TIMES)
           t1 = new ASTTimes(t1,t2);
       else if (op.kind == DIV)
           t1 = new ASTDiv(t1,t2);
       else if (op.kind == MOD)
           t1 = new ASTMod(t1,t2);
       else if (op.kind == POW)
           t1 = new ASTPow(t1,t2);
        }
		)?
     { return t1; } 
}


ASTNode IfElse():
{
    ASTNode c, b, e;
}
{
    <IF> c = BoolAdd() <LBRACKET>
        b = Seq()
    <RBRACKET> <ELSE> ( e = IfElse() | <LBRACKET> e = Seq() )
    { return new ASTIfElse(c, b, e); }
}

Bind<String, ASTNode> DefEq():
{
    Token n, mut;
    ASTNode t;
}
{
    { mut = new Token(); } (mut=<MUT>)? n = <Id> <EQ> t = BoolAdd()
    {
        if (mut.image != null && !mut.image.trim().equals("")){
            t = new ASTNew(t);
        }
        return new Bind<>(n.image, t);
    }
}

Bind<String, ASTNode> DefDDot():
{
    Token n, mut;
    ASTNode t;
}
{
    { mut = new Token(); } (mut=<MUT>)? n = <Id> <DDOT> t = BoolAdd()
    {
        if (mut.image != null && !mut.image.trim().equals("")){
            t = new ASTNew(t);
        }
        return new Bind<>(n.image, t);
    }
}

List<Bind<String, ASTNode>> DefVar():
{
    Token n;
    List<Bind<String, ASTNode>> l = new ArrayList<>();
    Bind<String, ASTNode> b;
}
{
    (<LET> b=DefEq() <SEMCOL>
    {
        l.add(b);
    })+
    { return l; }
}

ASTNode Array():
{
    Token n;
    ASTNode t;
}
{
    { List<ASTNode> l = new ArrayList<>(); }
    t = Fact() { l.add(t); }
    ( <COMMA> t = Fact() { l.add(t); })*
    { t = new ASTArray(l); }
    { return t; }
}

ASTNode Record():
{
    Bind<String, ASTNode> b;
    Token n;
    ASTNode t;
}
{
    { Map<String, ASTNode> m = new HashMap<>(); }
    b = DefDDot() { m.put(b.getId(), b.getValue()); }
    ( <COMMA> b = DefDDot() { m.put(b.getId(), b.getValue()); })*
    { t = new ASTRecord(m); }
    { return t; }
}

ASTNode Fact() :
{
    Token n;
    ASTNode t;
}
{
   (
      n=<INT> { t = new ASTInt(Integer.parseInt(n.image)); }
    | n=<BOOL> { t = new ASTBool(Boolean.parseBoolean(n.image)); }
    | n=<STR> { t = new ASTStr(n.image); }
    | <LSBRACKET> t = Record() <RSBRACKET>
    | n=<Id> { t = new ASTId(n.image); } ({ Token n2; } <DOT> n2=<Id> { t = new ASTRecordField(t, n.image, n2.image); })*
    | ("-" t = Fact() { t = new ASTNeg(t); })
    | <LPAR> t=BoolAdd() <RPAR>
    | <NOT> t=Fact() { t = new ASTNot(t); }
    | <LBRACKET>
        { List<Bind<String, ASTNode>> l; }
        l = DefVar()
        t = Seq()
        {
            t = new ASTDef(l, t);
        }
      <RBRACKET>
    | <NEW> <LPAR> t = BoolAdd() <RPAR> { t = new ASTNew(t); }
    | t = IfElse() <RBRACKET>
    | {
        //Token v;
        ASTNode v, cond, c, d;
        Map<List<ASTNode>, ASTNode> cases = new HashMap<>();
     }
     <MATCH> cond = BoolAdd() <LBRACKET>
         ({ List<ASTNode> p = new ArrayList<>(); } v = BoolAdd() { p.add(v); } (<VB> v = BoolAdd() { p.add(v); })* <DDOT> c = Seq() { cases.put(p, c); } <COMMA> )*
         <DEFAULTCASE> <DDOT> d = Seq()
     <RBRACKET>
     { t = new ASTMatch(cond, cases, d); }
    |{ ASTNode b; }
     <WHILE> t = BoolAdd() <LBRACKET>
            b = Seq()
            <RBRACKET>
    { t = new ASTWhile(t, b); }
   | { Token v; ASTNode b;}
    <FOR> n = <INT> <IN> v=<INT> <LBRACKET>
        b = Seq()
    <RBRACKET>
    { t = new ASTFor(Integer.parseInt(v.image) - Integer.parseInt(n.image), b); }
   | <REF> <LPAR> t=BoolAdd() <RPAR> { t = new ASTRef(t); }
   | <FUN> n = <Id> <LPAR> { Token n2; } n2 = <Id> <RPAR> <RBRACKET> t=Seq() <LBRACKET> { t = new ASTFunction(n.image, t); }
   | { List<ASTNode> l = new ArrayList<>(); }<PRINT> <LPAR> t = BoolAdd() { l.add(t); } ( <COMMA> t = BoolAdd() { l.add(t); })* <RPAR> { t = new ASTPrint(l); }
   | { List<ASTNode> l = new ArrayList<>(); }<PRINTLN> <LPAR> t = BoolAdd() { l.add(t); } ( <COMMA> t = BoolAdd() { l.add(t); })* <RPAR> { t = new ASTPrintln(l); }
   )
   { return t; }
}

/*ASTNode Value():
{
    ASTNode t;
    Token n;
}
{

}*/



















